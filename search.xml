<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人博客搭建记录]]></title>
    <url>%2F2018%2F01%2F17%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[2017年末，买了个人域名wolfxu.com，于是搭建了自己的个人博客。2018年初，逐步完善了博客的各种配置，从简书同步了之前的文章过来。 搭建记录 购买域名。在阿里云购买个人域名wolfxu.com，很幸运的有.com域名，而且不贵。一开始也纠结选什么后缀好，看了知乎上的一些回答，觉得还是.com好，.com是最自然、最好记的。至于.com原意是表示公司……这个不重要。 选择建站方案。不想买服务器，所以用github pages做静态博客。从主流的静态博客框架里面选择了hexo，原因是名字看着顺眼。而且据说编译速度比jekyll快。 在github创建用于存放静态博客的仓库。仓库名称必须是”用户名.github.io”，起其他名称是无效的。创建好对应的仓库后，就可以通过”用户名.github.io”这个地址来访问了。 绑定自定义域名。通过阿里云的dns解析，给wolfxu.com和www.wolfxu.com添加A记录到github pages的ip，有两个：192.30.252.153、192.30.252.154。然后在github的仓库下创建一个CNAME文件，写上wolfxu.com。这里写wolfxu.com和www.wolfxu.com都行；写wolfxu.com的话，访问www.wolfxu.com时，会被重定向到wolfxu.com；反过来的话，就重定向到www.wolfxu.com。通过我们的自定义域名访问时，实际上是访问github pages的服务器，github pages根据CNAME文件中配置的域名来进行匹配，展示相应仓库的内容。 安装hexo。先安装Node.js（我直接用homebrew安装的Node.js），然后安装hexo。 hexo初始化。hexo init 创建hexo需要的文件，然后npm install安装依赖的插件。我新建了一个hexo分支，用于存放源文件，把master留着用于发布。这样就能直接用hua3505.github.io的仓库管理源文件，不需要另外建一个仓库。 修改配置。修改了url、author等。 试试本地服务器。需要安装hexo-server插件，npm install hexo-server —save。这里save要加上，这样插件信息会被加到package.json中，方便多台电脑之间同步。在其他电脑上，从github拉取更新后，就可以看到缺少的插件，直接用npm install安装。hexo server（缩写hexo s），可以启动本地的服务，用于预览博客效果。修改内容后，不需要重启本地服务，只要刷新一下就可以看到修改的效果。 生成静态博客。hexo generate（缩写hexo g），所有生成的文件在public目录下。 部署。用git来进行部署。配置好部署的方式，仓库地址，分支等。安装hexo-deployer-git插件。执行hexo deploy部署。可以把生成和部署的命令合并，hexo generate -deploy（缩写hexo g -d），反过来也行hexo d -g。 解决hexo部署后，CNAME文件被删除的问题。hexo部署到master分支下，把原来的文件都删除了，CNAME被删，导致无法用自定义域名访问。解决方案是，把CNAME文件放到source目录下，这个文件下的一般文件在生成时，会被直接拷贝。具体可以看hexo关于“资源文件夹”的文档。 更换主题。一开始试了Aath，不好看。换了Next，简单大方，好看，而且功能很完善。折腾了一下主题配置。 从简书迁移文章过来。有些文章内有链接到我的其它文章，改成链接到wolfxu.com上的。另外遇到图片标注没显示，生成时报错等问题，在后面单独提一下。 配置文章阅读数、评论系统、站内搜索、公益404、首页显示摘要等。站内搜索用的是Algolia，发现Next的文档上写的hexo配置项中少了apiKey，应该有applicationID、apiKey、indexName三项。 hexo与简书的markdown的区别 图片标注。对于下面这样的图片引用，简书直接取方括号中的文字作为图片标注，而在hexo上，需要用后面双引号里的才行。应该是hexo的做法比较规范，前面的应该是alt text，后面的才是图片标注。为了在两边显示效果能保持一致，要写全，而且两处文字应该一样。 1![Snip设置](http://xxx "Snip设置") hexo似乎更为严格。无序列表符号“-”前有空格，生成时直接报错了]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java多线程开发（二）| 多线程的竞争与协作]]></title>
    <url>%2F2018%2F01%2F08%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[0. 前言 使用多线程的过程中，主要要解决的是两类问题： 多个线程共享资源 多个线程的协作 线程就像独立的个体，每个线程都有各自的任务。为了完成各自的任务，会去获取自己需要的资源，可能会和其他线程产生竞争。但每个线程的任务，最终都是为了实现共同的目标，线程与线程之间需要相互配合。而我们要做的，就是建立一种机制，让多个线程能合理地竞争，有效地合作。这么一想，管理多线程就像管理团队一样。团队的任务拆解到个人，每个人有各自的任务和目标，在执行过程中会用到相同的资源，成员之间也需要沟通和协作。管理团队不容易，管理多线程也要小心谨慎。 对 Java 的多线程机制不了解的同学，可以先看我的上一篇文章：Java多线程开发（一）| 基本的线程机制。 1. 多个线程共享资源1.1 不正确地访问资源 多个线程经常有需要共享的资源。有些是因为资源本身有限，比如打印机；有一些是出于协作的需要，比如共享变量。当两个以上的线程同时访问相同的资源时，很容易出现问题。 举个例子演示一下。想了很久找不出很好的例子，就用《Thinking in Java》书上的例子吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class IntGenerator &#123; private volatile boolean mCanceled = false; public abstract int next(); public void cancel() &#123; mCanceled = true; &#125; public boolean isCanceled() &#123; return mCanceled; &#125;&#125;public class EvenChecker implements Runnable &#123; private IntGenerator mGenerator; private final int mId; public EvenChecker(IntGenerator generator, int ident) &#123; mGenerator = generator; mId = ident; &#125; public void run() &#123; while (!mGenerator.isCanceled()) &#123; int val = mGenerator.next(); if (val % 2 != 0) &#123; System.out.println(val + " not even"); mGenerator.cancel(); &#125; &#125; &#125; public static void test(IntGenerator generator, int count) &#123; System.out.println("Press Control-C to exit"); ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; count; ++i) &#123; executor.execute(new EvenChecker(generator, i)); &#125; executor.shutdown(); &#125; public static void test(IntGenerator generator) &#123; test(generator, 10); &#125;&#125; IntGenerator 是产生数字的抽象类，EvenChecker 创建多个线程去调用 IntGenerator 的 next() 方法生成数字，并检测数字是否是偶数。 123456789101112131415161718192021public class EvenGenerator extends IntGenerator &#123; private int mCurrentEvenValue = 0; @Override public int next() &#123; ++mCurrentEvenValue; Thread.yield(); ++mCurrentEvenValue; return mCurrentEvenValue; &#125; public static void main(String[] args) &#123; EvenChecker.test(new EvenGenerator()); &#125;&#125;// 输出：11 not even15 not even17 not even19 not even21 not even EvenGenerator 用于生成偶数。在两个自增操作之间，增加了一个 Thread.yield() ，是为了更快地观察到现象。EvenGenerator 的 next() 被多个线程调用，mCurrentEvenValue 在这里就是多个线程共享的变量。从输出结果可以看到，由于线程在第一次自增操作之后切换，next() 返回的值会出现奇数。程序处于不正常的状态。 1.2 解决共享资源竞争问题 为了解决线程竞争共享资源导致的问题，通常让线程以序列化的方式访问资源，即同一时刻只能有一个线程访问资源。当一个线程在访问资源时，就不允许另一个线程访问，线程间的这种制约关系叫互斥。而同一时间只能被一个线程访问的资源叫临界资源，访问临界资源的代码块叫临界区。一般通过对临界区加锁，实现线程的互斥。 在 Java 中，对临界区加锁常用的方式有两种： synchronized 关键字 Lock 对象 1.2.1 synchronized 关键字 Java 中的 synchronized 关键字，为防止资源冲突提供了内置支持。当执行到 synchronized 关键字保护的代码块时，首先要获取锁，然后才能执行代码，执行完成后释放锁。synchronized 关键字的使用有如下几种形式： 修饰方法，synchronized void fun() {…} 修饰静态方法，synchronized static fun() {…} 包裹代码块，synchronized (obj) {…} 虽然 synchronized 关键字的使用有不同的形式，但本质上是一样的，都是对对象加锁。在 Java 中，所有对象都含有一个锁（源码注释中叫 monitor），synchronized 就是获取对象的锁。再回过头看一下 synchronized 的几种使用形式： 修饰方法，是对调用该方法的对象加锁 修饰 static 方法，是对 Class 对象加锁 修饰语句块，是对指定对象加锁 一个线程可以多次获得同一个对象的锁，比如在 synchronized 方法中调用另一个 synchronized 方法。JVM 会记录对象加锁的次数，已经获得锁的线程再次获得锁，计数加1。计数为0时，锁才被完全释放，其他线程才能获得这个锁。 使用 synchronized 关键字修改一下前面的例子，把 next() 方法用 synchronized 保护起来。这次不管运行多久，都不会出现 next() 返回奇数的情况了。 123456789101112131415public class SynchronizedEvenGenerator extends IntGenerator &#123; private int mCurrentEvenValue = 0; @Override public synchronized int next() &#123; ++mCurrentEvenValue; Thread.yield(); ++mCurrentEvenValue; return mCurrentEvenValue; &#125; public static void main(String[] args) &#123; EvenChecker.test(new SynchronizedEvenGenerator()); &#125;&#125; 1.2.2 Lock 对象 除了内置的 synchronized 关键字外。还可以使用 java.util.concurrent.locks 类库中 Lock 的对象来实现互斥。Lock 是一个接口。需要显示地创建 Lock 对象，然后调用 lock() 方法去获取锁，调用 unlock() 方法去释放锁。 12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 下面是使用 Lock 重写的 EventGenerator ，简单展示一下 Lock 的使用方法。注意，使用 Lock 时，尽量用 try-finally , 把 unlock() 方法的调用放到 finally 中。避免中途出现异常，导致锁无法被释放。 1234567891011121314151617181920212223public class MutexEvenGenerator extends IntGenerator &#123; private int mCurrentEvenValue = 0; private Lock mLock = new ReentrantLock(); @Override public int next() &#123; try &#123; mLock.lock(); ++mCurrentEvenValue; Thread.yield(); ++mCurrentEvenValue; return mCurrentEvenValue; &#125; finally &#123; // try-finally 的惯用法，保证锁能释放 mLock.unlock(); &#125; &#125; public static void main(String[] args) &#123; EvenChecker.test(new MutexEvenGenerator()); &#125;&#125; 和 synchronized 相比，Lock 的使用更麻烦，但同时也更灵活。因为锁的创建、加锁和释放都由我们控制，可以实现 synchronized 做不到的需求。下面列举一些 Lock 能做到，而 synchronized 无法实现的功能： 尝试获取锁，但如果锁已经被占用会直接返回而不阻塞；也可以设置尝试获取锁的等待时间，超时之后就返回。使用 Lock 的 tryLock() 方法即可。 等待锁导致阻塞时，能够被 interrupt() 方法打断。 更细粒度的控制，可以实现代码块之间交叉的加锁。比如，遍历链表时，要在释放当前节点的锁之前获取下一个节点的锁。 关于 synchronized 关键字和 Lock 对象的选择，尽量用 synchronized 。当 synchronized 满足不了需求的时候，才考虑用 Lock 。synchronized 使用更简单，而且相对来说更加安全。 java.util.concurrent.lock 包中，有三种锁。 Lock ，普通锁接口，有一个实现：ReentrantLock。 ReadWriteLock，包含读锁和写锁两个锁，这里的锁是 Lock 对象。也有一个实现：ReentrantReadWriteLock。 StampedLock，包含乐观读锁、悲观读锁、写锁三种模式锁，是一个具体的实现类。1.8才引入的，与 Lock 和 ReadWriteLock 完全无关。 对于 ReentrantReadWriteLock，有一点需要注意。 Thread1: A.readlock().lock() -&gt; … 已经拿到读锁 Thread2: A.writelock().lock() -&gt;.. .请求写锁 Thread3: A.readlock().lock() -&gt;… 等待，一直到 Thread2 获取到然后又释放写锁。 第一个线程获取了读锁，第二个线程在等待获取写锁。这时其他线程想要获取读锁的话，得等待第二个线程获取到写锁，做完事情，释放写锁。 1.3 原子性、可见性原子性：一个操作是不可中断的，开始执行就一定会完全执行完。这种操作被称为原子操作。 除了 long 和 dobule 之外的基本类型变量的读取和写入操作，都是原子性的。JVM 可以将 long 和 dobue 的读取和写入当成两个 32 位操作来执行，在中间可以发生切换。JVM 规范里面说明对 long 和 dobule 的读写操作不要求原子性，但是加了 volatile 关键字的 long 和 dobule 变量，必须是原子性的。 java.util.concurrent.atomic 类库提供了一系列原子操作的类，比如 AtomicInteger、AtomicLong、AtomicReference 等。它们能提供自增、赋值并读取等扩展的原子操作。 可见性：也可以叫作可视性、一致性。 在多处理器或者多核处理器系统中，一个任务修改了某个共享变量，但这个修改暂时只存在处理器的缓存中，还没有更新到主存中。对于运行在其他处理器上的任务来说，这个变量的修改时不可见的，它们看到的还是修改前的值。在 Java 的内存模型中，每个线程都有单独的工作内存，线程内变量的修改会先缓存在工作内存中。 volatile 关键字可以保证可见性，使变量的修改立即写入到主存中，读取时也从主存中读取变量的最新值。synchronized 可以保证加锁的方法或者代码块中的修改的可见性。 volatile 同时还能提供一定的有序性。对 volatile 变量的读写在一些情况下不会被重排序。具体可以参考这篇文章：深入理解Java内存模型（四）——volatile。Java内存访问重排序的研究。 1.４ 线程本地存储 有一些变量不希望被其他线程共享，那可以使用 ThreadLocal。顾名思义，通过 ThreadLocal ，每个线程可以存储只有自身能访问的变量。ThreadLocal 对象本身只有一个，但是它里面存的值是每个线程一个，完全独立的。Thread中持有 ThreadLocalMap的对象threadLocals，这个map完全由ThreadLocal创建和维护。ThreadLocal对象，获取到当前线程的ThreadLocalMap，往里面存值，所以每个线程的值都是独立的。ThreadLocalMap的key是ThreadLocal对象，value就是ThreadLocal要保存的值。 来看下面的例子。 1234567891011121314151617181920212223private static ThreadLocal&lt;Integer&gt; sVal = ThreadLocal.withInitial(() -&gt; (1));public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; executorService.execute(() -&gt; &#123; sVal.set(sVal.get() + 1); System.out.println(Thread.currentThread().getName() + " " + sVal.get()); &#125;); &#125; executorService.shutdown();&#125;// 输出：pool-1-thread-1 2pool-1-thread-2 2pool-1-thread-3 2pool-1-thread-2 3pool-1-thread-1 3pool-1-thread-3 3pool-1-thread-2 4pool-1-thread-2 5pool-1-thread-2 6pool-1-thread-4 2 因为 ThreadLocal 的对象 sVal 中存储的值应该是每个线程独立的，理论上输出都是 2 才对，但是最终的输出结果甚至有 6。这是因为，我们使用了线程池，而这里的任务执行时间太短，线程被复用了。这意味着线程中保存的值还是之前那个，所以会一直累加上来了。所以在使用线程池时，如果任务依赖 ThreadLocal 储存的值，那就需要小心了。 2 线程之间的协作 线程之间共享资源的问题解决了，接下来学习如何让线程之间彼此协作了。线程之间的协作，说白了，就是某些部分任务需要等待其他部分任务完成后，才能继续进行。我们可以通过 Object 的 wait() 和 notify() 方法来实现，也可以通过 Condition 对象的 await() 和 signal() 方法来实现。 2.1 wait()、notifyAll() 和 notify() 某些任务在执行时，会依赖某个条件，只有条件满足了才能继续执行，而这个条件是有其他任务改变的。如果我们只是不断地循环去检测这个条件，将会导致线程无意义地占用 CPU 资源，这被称为忙等待。而 wait() 可以在等待条件变化时，将任务挂起，等到 notify() 或者 notifyAll() 方法被调用时才会唤醒去检测条件是否满足。 ｗait() 、notify() 和 notifyAll() 都是 Object 类的方法。基于对象锁（monitor）实现。所以，调用这几个方法前，必须要先获得相应对象的锁，不然会抛出 IllegalMonitorStateExecption 异常。获取对象锁的方式就是使用 synchronized 关键字。 调用 wait() 方法挂起任务时，线程会释放获取到的对象锁，以让其他线程能够获得这个对象的锁。流程是这样的：在调用 wait() 之前，已经获得了该对象的锁；调用 wait() 的时候，会释放对象锁；而在从 wait() 唤醒之前，线程会重新获得对象锁。 下面是一个给汽车打蜡的例子，两个线程，一个负责打蜡，一个负责抛光。抛光任务要等待打蜡任务完成，而下一层打蜡任务要等待上一层蜡被抛光。使用 wait() 和 notify() 来进行任务同步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class WaxOMatic &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Car car = new Car(); executorService.execute(new WaxOn(car)); executorService.execute(new WaxOff(car)); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; executorService.shutdownNow(); &#125;&#125;class Car &#123; private boolean waxOn = false; synchronized void waxed() &#123; waxOn = true; notifyAll(); &#125; synchronized void buffed() &#123; waxOn = false; notifyAll(); &#125; synchronized void waitForWaxing() throws InterruptedException &#123; while (!waxOn) &#123; wait(); &#125; &#125; synchronized void waitForBuffing() throws InterruptedException &#123; while (waxOn) &#123; wait(); &#125; &#125;&#125;class WaxOn implements Runnable &#123; private Car car; WaxOn(Car car) &#123; this.car = car; &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; System.out.println("Wax On! " + System.currentTimeMillis()); Thread.sleep(200); car.waxed(); car.waitForBuffing(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("Exiting via interrupt"); &#125; System.out.println("Ending Wax On task"); &#125;&#125;class WaxOff implements Runnable &#123; private Car car; WaxOff(Car car) &#123; this.car = car; &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; car.waitForWaxing(); System.out.println("Wax Off! " + System.currentTimeMillis()); Thread.sleep(200); car.buffed(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("Exiting via interrupt"); &#125; System.out.println("Ending Wax On task"); &#125;&#125; 一般使用 wait() 方法，应该用一个 while 循环去检查条件。因为无法保证唤醒的时候，条件是否满足，在每次唤醒后去检查才能保证安全。有很多可能性导致唤醒的时候条件并不满足： 有多个任务因为相同的原因在等待。第一个被唤醒的任务先进行了处理，条件又变成不满足了。 被唤醒时，其他任务做了一些操作，影响到了当前条件。 多个任务因为不同的原因在等待。因为要唤醒其他任务而被连带唤醒了。 1234synchronized (monitor)while (someCondition) &#123; monitor.wait();&#125; 错失的信号 当两个线程使用 wait() / notify() / notifyAll() 进行协作时，有可能出现错过某个信号的情况。 1234567891011121314T1:synchronized(sharedMonitor) &#123; &lt;setup condition for T2&gt; someCondition = false; sharedMonitor.notify();&#125;T2:while (someCondition) &#123; // Point1. 在这个时间点被切换 synchronized(sharedMonitor) &#123; sharedMonitor.wait(); &#125;&#125; T2 线程先执行，判断条件 someCondition 为 true。在 Point1 这个时间点被切换了。T1 执行，someCondition 变为 false，并且调用 notify() 。T2 继续执行，这时已经晚了，T2 调用 wait() 进行等待。而 notify() 已经错过了，T2 将一直在 wait() ，等不到唤醒的信号。这个也算是共享资源的竞争导致的问题。为了避免这种情况，我们应该把对条件的判断和 wait() 放在同一个 synchronized 代码块中。 123456T2:synchronized(sharedMonitor) &#123; while (someCondition) &#123; sharedMonitor.wait(); &#125;&#125; notify() 还是 notifyAll() notify() 和 notifyAll() 。如果有多个线程在同一个对象上等待，notify() 会选择一个唤醒。因此，使用 notify() 的时候得确保唤醒的是你想要的线程。不然的话，还是只能用 notifyAll() 。 2.2 使用 Lock 和 Condition 对象 跟互斥一样，除了 Java 内建的 wait() 和 notify() 上，java.util.concurrent 类库中还提供了显示的工具来进行线程的同步。就是 Condition，也是一个接口。使用 Condition 对象，可以调用 await() 来挂起一个任务，通过调用 signal() 或者 signalAll() 来唤醒任务。 Condition 是一个接口，但是 Condition 类的文档注释中对 Condition 的实现做了严格的要求。Condition 对象应该关联到 Lock， 应该通过 Lock 对象的 newCondition() 方法生成。Lock 和 Condition 的使用，基本上就和 synchronized 和 wait()/notify() 的用法差不多。调用 await()、singnal() 和 singnalAll() 等方法前，应该先对关联的 Lock 对象上锁，不然要抛出 IllegalMonitorStateException 异常。调用 await() 挂起任务时，会释放关联的锁，被唤醒前，重新获得锁。 使用 Lock 和 Condition 好处是：Lock 和 Condition 都是自己创建的，使用上更灵活。比如，每个等待的条件可以专门弄一个 Condition 对象，这样可以更精确地控制唤醒的线程，优化程序的执行效率。 下面是用 Lock 和 Condition 重写的给汽车打蜡的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class WaxOMaticWithCondition &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Car car = new Car(); executorService.execute(new WaxOn(car)); executorService.execute(new WaxOff(car)); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; executorService.shutdownNow(); &#125; static class Car &#123; private boolean waxOn = false; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); void waxed() &#123; lock.lock(); try &#123; waxOn = true; condition.signalAll(); &#125; finally &#123; // 养成好习惯，把 unlock 放到 finally 中，避免异常导致锁无法释放 lock.unlock(); &#125; &#125; void buffed() &#123; lock.lock(); try &#123; waxOn = false; condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; void waitForWaxing() throws InterruptedException &#123; lock.lock(); try &#123; while (!waxOn) &#123; condition.await(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; void waitForBuffing() throws InterruptedException &#123; lock.lock(); try &#123; while (waxOn) &#123; condition.await(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; static class WaxOn implements Runnable &#123; private Car car; WaxOn(Car car) &#123; this.car = car; &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; System.out.println("Wax On! " + System.currentTimeMillis()); Thread.sleep(200); car.waxed(); car.waitForBuffing(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("Exiting via interrupt"); &#125; System.out.println("Ending Wax On task"); &#125; &#125; static class WaxOff implements Runnable &#123; private Car car; WaxOff(Car car) &#123; this.car = car; &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; car.waitForWaxing(); System.out.println("Wax Off! " + System.currentTimeMillis()); Thread.sleep(200); car.buffed(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("Exiting via interrupt"); &#125; System.out.println("Ending Wax Off task"); &#125; &#125;&#125; 2.3 阻塞队列 阻塞队列（BlockingQueue），解决“生产者-消费者”问题的神器，因为它内部为我们实现了线程之间的同步，可以极大地简化代码。当某个线程试图从阻塞队列中取一个对象是，如果队列为空，线程会被挂起等待。往阻塞队列添加对象也是一样，当队列已满时，线程会被挂起等待。 主要关注以下几个方法： 添加元素的方法： put(E)。队列已满时，挂起线程，一直到队列中有空位。 offer(E): boolean。队列已满时，返回 false，表示添加失败。 offer(E, long, TimeUnit): boolean。队列已满时，等待一段时间。超时后，返回 false，表示添加失败。 add(E): boolean。添加成功，返回 true 。队列已满时，抛出异常。AbstractQueue 的实现是直接调用 offer(E) ，失败就抛出异常。 取出元素的方法： take(): E。队列为空时，挂起线程，一直到有新的元素插入。 pull(long, TimeUnit): 队列为空时，挂起线程，等待一段时间。超时后，返回 null 。 线程池（ThreadPoolExecutor ）就是依赖于阻塞队列实现的，任务被添加到阻塞队列中，线程从阻塞队列中获取任务。 3. 结束线程 前面提到的 synchronized 和 Lock 等，都会导致线程阻塞。那么，怎么结束阻塞状态的线程呢？先来看看 Java 中的线程有哪几种状态。 新建（new）。线程刚被创建时，短暂地处于这种状态 就绪状态（RUNNABLE）。线程正在 JVM 中执行。但是线程可能正在等待操作系统的处理器资源。 阻塞状态（BLOCKED、WAITING、TIMED_WAITING）。根据阻塞的原因区分了三种，这里我们详细区分。 终止状态（Terminated）。 为什么没有RUNNING状态，因为线程获得处理器资源去实际执行，这是操作系统负责的，JVM 不管这事儿。对JVM 来说，它只知道线程当前是就绪状态，至于是在等待处理器还是实际在执行并不关心。具体可以看这篇文章。Java 线程状态之 RUNNABLE。 进入阻塞状态的原因： sleep wait 等待输入输出 synchronized 或者 Lock 对阻塞状态的线程调用 interrupt() 方法，将抛出 InterruptedException。可以用来中断线程。如果不想或者不方便直接对线程对象操作。也可以通过 executor 的 submit 方法执行 Runable，拿到 Future 对象，调用 Future 对象的 cancel 方法。cancel 方法实际上也是调用 interrupt。 sleep wait 等阻塞可以被 interrupt() 中断，但 io 和 synchronized阻塞 不能被中断。Lock 有 lockInterruptibly() 方法，可以被中断。对于像 io 引起的阻塞，可以通过关闭底层资源来结束线程。线程池的 shutdownNow() 方法也是调用 interrupt() 方法的，也无法结束被 io 和 synchronized 阻塞的线程。 4. 死锁 对于临界资源，我们使用互斥锁来保证同一时刻只能有一个线程在访问。但是，使用互斥锁也容易出现死锁的问题。死锁，指的是两个或两个以上的线程（进程），每个线程持有部分资源，而又等待其他线程的资源，形成环路地等待，导致所有线程都永远无法拿到所有所需的资源。 产生死锁的四个必要条件： 互斥条件。 不可抢占条件。 占有且申请条件。 环路等待条件。 预防死锁的办法。破坏一个条件即可。 打破互斥条件。让资源允许共享。 打破不可抢占条件。线程请求不到资源时，释放已获取的资源。 打破占有且申请条件。线程一次性申请所有资源。 打破环路等待条件。把资源排序，所有线程按顺序请求资源，不会出现环路等待的情况。 5. 结语 多线程开发主要要解决的问题是竞争与协作。对于竞争，有 synchronized 关键字和 Lock 对象两种方式来实现互斥。对于协作，也有 synchronized+wait()/notify() 和 Lock + Condition 两种方式实现任务的等待。至此，我们已经对 Java 多线程开发有了较为全面地理解。下一篇文章将研究一下 Java 并发包下给我们提供的一些好用的工具。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程开发（一）| 基本的线程机制]]></title>
    <url>%2F2018%2F01%2F08%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[0. 前言 Java 为了实现跨平台，在语言层面上实现了多线程。我们只需要熟悉 Java 这一套多线程机制就行了，比 C/C++ 要容易多了。 1. 定义任务 我们编写程序，最终是为了完成特定的任务。为了更有效的利用系统资源，我们把任务合理地划分成多个子任务，放到多个线程中来执行。所以，首先我们需要一种描述任务的方式。在 Java 中，一般我们都用 Runable 接口来定义任务。 1234public interface Runnable &#123; // 在run方法中定义任务 public void run();&#125; 想要定义任务，只需要实现 Runable 接口，然后在 run() 方法中写上执行步骤。请注意，Runable 只是定义了一个任务，本身不会去启动一个新线程来执行。看下面的例子。可以看到，在外面直接打印的线程名和在 Runable 的 run() 方法中打印的线程名是相同的。 12345678910public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;; runnable.run();&#125; 输出结果： mainmain 2. Thread类 ​ 要让任务在新的线程执行，最直接的方法是用它来创建一个 Thread 类。这里用 Thinking in Java 书上的例子来展示 Thread 类的使用。 12345678910111213141516171819202122232425262728/** * 显示发射之前的倒计时 */public class LiftOff implements Runnable &#123; private static int sTaskCount = 0; private final int mId = sTaskCount++; protected int mCountDown = 10; public LiftOff() &#123; &#125; public LiftOff(int countDown) &#123; mCountDown = countDown; &#125; private String status() &#123; return "#" + mId + "(" + ((mCountDown &gt; 0) ? mCountDown : "Liftoff!") + "), "; &#125; @Override public void run() &#123; while (mCountDown-- &gt; 0) &#123; System.out.print(status()); Thread.yield(); // Thread.yield() 是对线程调度器的一种建议，表示当前线程准备让出处理器 &#125; &#125;&#125; LiftOff 任务会显示发射前的倒计时。注意在 run() 方法中调用的 Thread.yield() 方法。这个方法的作用是对线程调度器的一种建议，表示当前线程可以让出处理器。当然，线程调度器不一定会真的切换执行线程。LifiOff 任务整个执行时间实际上很短，如果不使用 Thread.yield() 很可能直到任务执行完成线程调度器才会切换新的线程，不利于观察多线程的效果。 123456789101112public class MoreBasicThreads &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new LiftOff()).start(); &#125; System.out.println("Waiting for Liftoff"); &#125;&#125;输出结果：#0(9), #1(9), #2(9), #3(9), #0(8), Waiting for Liftoff#4(9), #1(8), #2(8), #3(8), #0(7), #4(8), #1(7), #2(7), #3(7), #0(6), #4(7), #1(6), #2(6), #3(6), #0(5), #4(6), #1(5), #2(5), #3(5), #0(4), #4(5), #1(4), #2(4), #3(4), #0(3), #4(4), #1(3), #2(3), #3(3), #0(2), #4(3), #1(2), #2(2), #3(2), #0(1), #4(2), #1(1), #2(1), #3(1), #0(Liftoff!), #4(1), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!), ​ Thread的构造器接收 Runable 对象，并在调用 start() 方法之后启动新的线程去执行 Runable中的 run() 方法。输出结果很有意思。我们启动了5个发射前的倒计时任务，“ Waiting for Liftoff ” 在倒计时没完成之前就输出了，这证明现在的任务确实是在新的线程执行的。各个任务的倒计时混杂在一起，说明不同任务的执行线程在被不断的换进换出。 3. 使用Executor java.util.concurrent 包中的执行器（ Executor ），可以帮我们管理Thread对象。 Executor 是一个接口，只有一个方法，就是 execute 。当我们把一个 Runable 交给 Executor 去执行，它可能会启动一个新的线程、或者从线程池中选择一个线程、甚至直接使用当前线程。但是，这些我们都不需要关心，我们只需要选择合适的 Executor 的实现，然后把任务扔给它去执行就好了。 1234567891011121314public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &#123;@code Executor&#125; implementation. * * @param command the runnable task * @throws RejectedExecutionException if this task cannot be * accepted for execution * @throws NullPointerException if command is null */ void execute(Runnable command);&#125; 先来看一个具体的使用示例。在这个示例中，我们通过 Executors 来创建了一个 线程池 CachedThreadPool。并通过这个线程池来执行5个发射前的倒计时任务。 123456789public class CachedThreadPool &#123; public static void main(String[] args) &#123; ExecutorService exectorService = Executors.newCachedThreadPool(); for (int i=0; i&lt;5;++i) &#123; exectorService.execute(new LiftOff()); &#125; exectorService.shutdown(); &#125;&#125; 在上面的示例中有几个需要解释的概念： Executors：一个工厂和工具类。 ExecutorService：有生命周期的 Executor 。也是一个接口，继承于 Executor 。 CachedThreadPool：线程池。当新任务过来，会首先找池中有没有可用的线程，没有才新建线程。 在 Executors 中还定义了另外三种线程池：FixedThreadPool 、SingleThreadPool 、 ScheduledThreadPool （也提供了单线程的 ScheduledThreadPool ）。FixedThreadPool 线程数量是稳定的，线程创建后不会销毁，达到设定的数量后，不再创建新线程。SingleThreadExecutor 是只能有一个线程的线程池。而 ScheduledThreadPool 可以定时执行任务。现在把上面的示例中的 CachedThreadPool 换成 FixedThreadPool ，最大线程数量为3。 123456789101112public class FixedThreadPool &#123; public static void main(String[] args) &#123; ExecutorService exector = Executors.newFixedThreadPool(3); for (int i=0; i&lt;5;++i) &#123; exector.execute(new LiftOff()); &#125; exector.shutdown(); &#125;&#125;输出结果：#1(9), #2(9), #0(9), #1(8), #2(8), #0(8), #1(7), #2(7), #0(7), #1(6), #0(6), #2(6), #1(5), #0(5), #2(5), #1(4), #0(4), #2(4), #1(3), #0(3), #2(3), #0(2), #1(2), #0(1), #2(2), #0(Liftoff!), #1(1), #2(1), #1(Liftoff!), #2(Liftoff!), #3(9), #4(9), #3(8), #4(8), #3(7), #4(7), #3(6), #4(6), #3(5), #4(5), #3(4), #4(4), #3(3), #4(3), #3(2), #4(2), #3(1), #4(1), #3(Liftoff!), #4(Liftoff!), 从输出结果可以看到，只有三个任务在同时执行。后面两个任务等前面的任务执行完成了，才开始执行。 对线程池的进一步研究 来看一下 Executors 中这四种线程池是怎么创建的。 123456789101112131415161718192021222324252627public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123; ...&#125; 前面三种线程池，都是直接创建了 ThreadPoolExecutor 类的对象。ScheduledThreadPool 因为要实现定时功能，创建的是 ScheduledThreadPoolExecutor 类的对象。但 ScheduledThreadPoolExecutor 也是继承自ThreadPoolExecutor 。所以我们主要关注一下 ThreadPoolExecutor 。下面这个构造方法是参数最全的一个。 123456789101112131415161718192021222324/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize 线程池中维持的线程数量。 * 当线程数量不超过这个数时，即使线程处于空闲状态也不会被销毁，会一直等待任务到来。 * 但是如果设置 allowCoreThreadTimeOut 为 true，corePoolSize 就不再有效了。 * @param maximumPoolSize 线程池中线程的最大数量。 * @param keepAliveTime 当线程数量超过了 corePoolSize 时，多余的线程销毁前等待的时间。 * @param unit keepAliveTime 的时间单位 * @param workQueue 用来管理待执行任务的队列。 * @param threadFactory 创建线程的工厂。 * @param handler RejectedExecutionHandler 接口的实现对象。用于处理任务被拒绝执行的情况。 * 被拒绝的原因可能是所有线程正在执行任务而任务队列容量又满了 */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ...&#125; 理解了这些参数，就很容易理解 Executors 中创建的几种线程池。当这几种线程池都不能满足需求的时候，我们直接可以通过 ThreadPoolExecutor 的构造方法来创建一个合适的线程池。那么，ThreadPoolExecutor 是怎么调度线程来执行任务的呢？ 从 execute() 方法入手去理解。其中 ctl 只是一个原子操作的 int 型（AtomicInteger类）变量，但可以同时保存线程池状态和线程数量。我在另一篇文章中专门分析了这个 ctl 的实现。 1234567891011121314151617181920public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command);&#125; 如果线程数量小于核心线程数量，就创建新的线程来执行任务；不然就添加到任务队列中；如果添加到任务队列失败，就创建新的线程来执行；如果创建线程再失败（可能是线程池不再是RUNNING状态，或者线程数量已经达到了最大线程数量），就只能拒绝任务了。 上面说的线程，实际上都通过 Worker 来管理，每个 Worker 对象持有一个线程。而 Woker 实现了 Runable 接口，会在自己的管理的线程中来执行。Worker 的 run() 方法就是直接调用了 runWorker 这个方法。 12345678910111213final void runWorker(Worker w) &#123; ... Runnable task = w.firstTask; w.firstTask = null; ... while (task != null || (task = getTask()) != null) &#123; ... task.run(); ... &#125; ... processWorkerExit(w, completedAbruptly);&#125; 如果在创建 Worker 时，就指定了一个任务，会先执行这个任务。后面就是循环，不断地从任务队列获取任务去执行。获取任务时，核心线程会一直等待获取到新的任务。而一般线程会设置一个超时时间，这个时间就是创建线程池时指定的 keepAliveTime。超时之后，就退出循环了，Worker 的使命完成，马上会被释放。有两点要补充一下： 核心线程和一般线程没有区分，只是去 getTask 时，根据当前线程的数量是否大于核心线程数量来决定要不要一直等待。 可以设置 allowCoreThreadTimeOut 为 true，让核心线程获取任务时也会超时。 现在我们基本上搞清楚了线程池是如何调度线程来执行任务的。再来回顾一下前面 Executors 中创建的几种线程池。 Executors中创建的CachedThreadPoollExecutor，是用的同步队列，只有当前有线程在等待任务时，才能加入，实际上也不在队列中管理，是直接扔给了执行线程去执行。所以CachedThreadPool中，当新任务到来时，如果线程数小于核心线程数，是直接创建，不然就看当前有没有在等待任务的线程，有就交给该线程执行，没有就创建一个新线程去执行。 Executors中创建的FixedThreadPoolExecutor和SingleThreadlExecutor，都是核心数量等于最大数量，且它们的任务队列是无限容量的。当新任务到来时，如果线程数小于核心线程数，创建新线程去执行，不然就加到任务队列中等待。 最后，研究一下 ScheduledThreadPoolExecutor 是怎么实现定时任务的。ScheduledThreadPoolExecutor 实现了 ScheduledExecutorService 接口中的 schedule 等方法。调用 schedule() 方法时，会把需要定时执行的任务打包在 ScheduledFutureTask 对象中，然后加入到等待执行的队列中去。 123456789public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t); return t;&#125; ScheduledThreadPoolExecutor 中用 DelayedWorkQueue 来管理等待执行的任务。添加时，会根据执行时间，把任务排到队列中合适的位置，保证队列中的任务按执行时间先后排列。取出时，取队列头部的任务，如果队列头部没有任务，或者任务的执行时间还没到，就要等待。 12345678910111213private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123; if (isShutdown()) reject(task); else &#123; super.getQueue().add(task); if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task)) task.cancel(false); else ensurePrestart(); &#125;&#125; delayedExecute() 方法中，先把任务加入到任务队列中，然后调用 ensurePrestart() 方法去启动一个新线程（线程数量小于限定的核心线程数量才会启动新线程）。这个线程就会去队列中等待任务，任务队列会在任务执行时间到时返回任务给线程去执行。这样就实现了定时任务的执行。 4. 从任务中产生返回值 前面我们用 Runable 来定义任务，但是 Runable 执行完成后不会有返回值。当需要返回值时，可以实现 Callable 接口。Callable 需要通过 ExecutorService 中声明的 submit() 方法去执行。 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 下面举一个计算年级平均分的例子。为了简化，假定每个班学生人数都是50人。为了计算年级平均分，要让各班去计算各自的总分。每个班计算总分的过程用 Callable 去执行。123456789101112131415161718192021222324252627282930313233343536373839private static final int STUDENT_NUM_OF_EACH_CLASS = 50;static class ClassScoreCaculator implements Callable&lt;Integer&gt; &#123; private List&lt;Integer&gt; loadScore() &#123; List&lt;Integer&gt; scoreList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; STUDENT_NUM_OF_EACH_CLASS; ++i) &#123; scoreList.add((int) (Math.random() * 100)); &#125; return scoreList; &#125; @Override public Integer call() throws Exception &#123; List&lt;Integer&gt; scoreList = loadScore(); Integer sum = 0; for (Integer score : scoreList) &#123; sum += score; &#125; return sum; &#125;&#125;public static void main(String[] args) &#123; List&lt;Future&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 12; ++i) &#123; results.add(executor.submit(new ClassScoreCaculator())); &#125; int sumScore = 0; for (Future&lt;Integer&gt; result : results) &#123; try &#123; sumScore += result.get(); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; int average = sumScore / (STUDENT_NUM_OF_EACH_CLASS * 12); System.out.print("average score is " + average);&#125; submit() 方法会返回 Future 对象。可以用 get() 方法去获取执行结果，get() 方法会一直阻塞，直到 Callable 执行完成返回结果。如果不希望阻塞，可以先用 isDone() 方法查询是否执行完成。也使用带超时时间参数的 get() 方法。注意到 get() 方法会抛出两种异常：InterruptedException 和 ExecutionException 。其中，InterruptedException 是调用 Future 对象的 cancel() 方法去取消任务时，可能会中断线程而抛出的异常。而 ExecutionException ，是执行任务过程中的异常。因为，Callable 的 call() 方法是会抛出异常的，这个异常会被封装到 ExecutionException 中抛出。 5. 休眠 当我们需要任务暂停一段时间，可以使用线程的 sleep() 方法。在线程休眠过程中，可能会有其他线程尝试中断当前线程，这时 sleep() 方法会抛出 InterruptedException ，结束休眠。我们可以在 catch 到中断异常之后，选择尽快结束当前线程的执行任务，当然也可以忽略，选择继续执行。 12public static native void sleep(long millis) throws InterruptedException;public static void sleep(long millis, int nanos) throws InterruptedException &#123;...&#125; 6. 优先级 线程的优先级表示线程的重要性，线程调度器倾向于让优先级高的线程先执行。可以用 Thread 的 getPriority() 方法读取线程的优先级，通过 setPriority() 方法可以修改线程的优先级。目前 Java 中的线程是映射到底层操作系统的线程，通过底层操作系统来实现的。所以优先级也被映射到底层操作系统中的线程优先级。但是，不同操作系统的优先级级别数量、策略都有所不同，Java 中的 10 个优先级并不能映射得很好。Thinking in Java 书上建议，调整优先级时，只使用 MAX_PRIORITY、NORM_PRIORITY 和 MIN_PRIORITY 三种级别。由于不同操作系统的线程调度策略不一样，因此我们在开发时不应该依赖于线程的执行顺序。 7. 让步 通过 Thread 的 yield() 方法，可以给线程调度器一个建议：当前线程的工作告一段落，可以让出 CPU 给其他线程使用了。当然，这只是一个建议，没有任何机制能保证它一定被采纳。所以，我们在开发时也不应该依赖于 yield() 方法。 8. 后台线程 后台（daemon）线程，也有就守护线程的。关于后台线程需要了解的主要有三点： 当所有非后台线程结束，程序也就会结束，所有的后台进程都被杀死。因此，不要把必须执行的任务放到后台线程中。 通过 setDaemon(true) 可以把线程标记为后台线程。这个方法要在线程开始运行之前调用，不然会抛出异常。 后台线程中创建的线程会被自动设成后台线程。原理是线程初始化的时候会获取当前线程的 daemon ，来设置自己的 daemon 。 下面看一个使用后台线程的例子。 123456789101112131415161718192021222324252627282930313233public class DaemonThreadStudy &#123; private static class DaemonThreadFactory implements ThreadFactory &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r); thread.setDaemon(true); return thread; &#125; &#125; private static class DaemonFromFactory implements Runnable &#123; @Override public void run() &#123; try &#123; while (true) &#123; Thread.sleep(100); System.out.println(Thread.currentThread() + " " + this); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Executor executor = Executors.newCachedThreadPool(new DaemonThreadFactory()); for (int i = 0; i &lt; 10; i++) &#123; executor.execute(new DaemonFromFactory()); &#125; System.out.println("All daemons started"); Thread.sleep(100); &#125;&#125; 9. join 一个线程如果要等待另一个线程执行完成，可以调用另一个线程的 join() 方法。调用 join() 方法之后，当前线程将被挂起，等待另一个线程执行结束。join() 方法也有一个带等待时间参数的重载版本，等待时间到了后，不管等待的线程是否执行完成都会返回。来看一个使用 join() 方法的例子。 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; Thread sleeper = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + " interrupted"); &#125; System.out.println(Thread.currentThread().getName() + " has awakend"); &#125; &#125;, "Sleeper"); Thread joiner = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; sleeper.join(); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + " interrupted"); &#125; System.out.println(Thread.currentThread().getName() + " join completed"); &#125; &#125;, "Joiner"); sleeper.start(); joiner.start();&#125; 在上面的例子中，sleeper 休眠 10 秒，而 joiner 会一直等待 sleeper 执行完成。注意，join() 方法和 sleep() 方法一样会抛出中断异常。也就是说，线程在等待时，也可以通过调用 interrupt 方法去中断它。 来看一下 join() 方法的实现。 1234567891011121314151617181920212223public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 实际上就是调用了线程对象的 wait() 方法。循环判断线程是否执行结束，没结束就继续 wait()。如果设置了超时时间的话，会在时间到了之后结束 wait()，退出循环。按照注释中的说法，Thread 对象在 terminate 的时候，会调用 notifyAll() 。这样，wait() 方法就能返回，join() 方法也就执行完了。为什么需要设个循环去判断 isAlive() 呢，因为我们有可能在程序的其他地方去调用被等待的线程对象的 notify() 和 notifyAll() 方法。如果没有循环的，join() 就会直接返回，不会等到线程执行结束了。 测试在其他地方调用被等待的线程的 notify() 方法时，还发现调用一个对象的 wait()、notify()、notifyAll() 等方法都需要先成为这个对象的 monitor 所有者，不然会抛出 IllegalMonitorStateException 异常。成为一个对象的 monitor 所有者有三种方法： 在这个对象的 synchronize 的方法中 在 synchronize 这个对象的代码块中 如果这个对象是 Class 类的对象，可以在类的静态的 synchronize 的方法中 其实三种方法本质上都是一样的，就是在调用 wait()、notify() 方法之前，得先对对象做 synchronize 。前面两种就不用说了。第三种方法，由于 Class 类的特殊性，类的静态的 synchronize 的方法，实际上就是对 Class 对象做的 synchronize。 10. 线程组 ThreadGroup ，这个东西没太大作用。看了书和很多资料，都说没什么意义。看了 ThreadGroup 类的源码，就是持有一个线程数组和一个线程组数组，方便进行统一操作，比如：interrupt() 方法。除此之外，还能通过 activeCount() 方法获取一下线程组内的线程数量。有些作用的是，ThreadGroup 可以对线程运行中没有被捕获的异常做处理。 11. 捕获异常 由于线程的特性，我们无法捕获从线程中逃逸的异常。一旦异常逃出任务的 run() 方法，就会向外传播 。我们需要用特殊的方式捕获线程中逃出的异常。在 Java 1.5 以前只能用线程组来捕获，在 1.5 版本之后，就有更好的方式可以处理了。 1234567891011121314151617class ExceptionRunable implements Runnable &#123; @Override public void run() &#123; throw new RuntimeException(); &#125;&#125;class NativeExceptionHandling &#123; public static void main(String[] args) &#123; try &#123; Executor executor = Executors.newCachedThreadPool(); executor.execute(new ExceptionRunable()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在上面的示例中，我们执行了一个会抛出异常的任务，并尝试用 try catch 去捕获异常，很显然，这是没有作用的，因为异常是在新的线程中抛出的。那么，我们改怎么去捕获这种异常呢？Java 1.5 引入了一个新的接口 Thread.UncaughtExceptionHandler，我们可以给线程设置一个异常处理器，去处理没有被捕获的异常。 123456789101112131415161718192021222324class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println("caught " + e); &#125;&#125;class HandlerThreadFactory implements ThreadFactory &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r); thread.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler()); return thread; &#125;&#125;class CaptureUncaughtException &#123; public static void main(String[] args) &#123; Executor executor = Executors.newCachedThreadPool(new HandlerThreadFactory()); executor.execute(new ExceptionRunable()); &#125;&#125; 这里我们使用了 HandlerThreadFactory 来创建线程，通过调用 Thread 的成员方法 setUncaughtExceptionHandler() 给每个线程设置了 UncaughtExceptionHandler 。线程运行中没有被捕获的异常，会被扔给 UncaughtExceptionHandler 来处理，而不会向外传递。 进一步研究，看异常是怎么被传到处理器中的。先看 Thread 类中的 dispatchUncaughtException() 方法，这个方法是由 JVM 去调用的。之前的流程应该就是线程执行任务后，有没捕获的异常，然后 JVM 调用线程的 dispatchUncaughtException() 方法来处理异常。然后，获取异常处理器，把异常交给异常处理器的 uncaughtException() 方法。如果该线程对象设置了异常处理器，就用自身的，否则就交给线程组处理（ThreadGroup 也实现了 UncaughtExceptionHandler 接口）。 1234567891011121314151617181920public class Thread &#123; ... private volatile UncaughtExceptionHandler uncaughtExceptionHandler; private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler; private ThreadGroup group; ... /** * Dispatch an uncaught exception to the handler. This method is * intended to be called only by the JVM. */ private void dispatchUncaughtException(Throwable e) &#123; getUncaughtExceptionHandler().uncaughtException(this, e); &#125; public UncaughtExceptionHandler getUncaughtExceptionHandler() &#123; return uncaughtExceptionHandler != null ? uncaughtExceptionHandler : group; &#125; ...&#125; 线程组中的处理流程是：首先找父线程组的处理方法；其次找线程中设置的默认异常处理器；都找不到就直接打印异常堆栈。12345678910111213141516171819public class ThreadGroup &#123; ... public void uncaughtException(Thread t, Throwable e) &#123; if (parent != null) &#123; parent.uncaughtException(t, e); &#125; else &#123; Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler(); if (ueh != null) &#123; ueh.uncaughtException(t, e); &#125; else if (!(e instanceof ThreadDeath)) &#123; System.err.print("Exception in thread \"" + t.getName() + "\" "); e.printStackTrace(System.err); &#125; &#125; &#125; ...&#125; 总结一下，线程执行中没捕获的异常优先扔给线程对象中设置的异常处理器，其次给线程组，如果都没处理，会看是否设置了 Thread 类的默认异常处理器。 看到这里，我产生了一个疑问，按照这种机制，没捕获的异常最多是打个错误信息，而不会导致程序 crash 。那么，为什么在 android 中，异常会导致应用 crash 呢。原来，Android 在所有进程启动时，都给 Thread 设置了 defaultUncaughtExceptionHandler ，遇到异常时会让应用 crash 。想了解更多内容，请看这篇文章 理解Android Crash处理流程 。 12. 结语 这篇文章是我阅读《 Thinking In Java 》书中并发一章第2节，并结合源码以及测试的学习记录。对 Java 基础线程机制的学习到此就告一段落了。下一篇文章学习多线程开发的两个主要问题的解决：Java多线程开发（二）| 多线程的竞争与协作。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor 中的 ctl 变量]]></title>
    <url>%2F2018%2F01%2F08%2FThreadPoolExecutor-%E4%B8%AD%E7%9A%84-ctl-%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[最近在看 Java 线程池的实现，发现里面有一个 int 类型的成员变量，同时表示线程池运行状态和线程数量。理解了一下这块的实现，挺有意思的，所以单独拿出来跟大家分享一下。 为什么要研究一个 int 变量其实一开始，我是在看 execute 方法的实现…… 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 这里 c 用来获取线程数量 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 这里 c 用来判断线程池是否处于运行状态 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command);&#125; 我注意到从 ctl（AtomicInteger类型） 中取出来的这个 int 变量 c，它一会儿用来获取线程数量，一会儿又用来判断线程池是否处于运行状态。我很好奇，于是点进去看了这两个方法的实现。 1234567private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; 这下就更疑惑了。CAPACITY 是什么？是怎么通过按位与运算得到线程数量的呢？SHUTDOWN 又是什么？有点意思，我决定好好研究一下它是怎么实现的。 怎么实现的来看一下 ctl 这个成员变量以及相关的值的声明。 123456789101112private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3; // 29private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 00011111 ... ... 11111111// 状态在高位存储private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 11100000 ... ... 00000000private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // 00000000 ... ... 00000000private static final int STOP = 1 &lt;&lt; COUNT_BITS; // 00100000 ... ... 00000000private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 01000000 ... ... 00000000private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 01100000 ... ... 00000000private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; ctl 是一个 AtomicInteger 的类，就是让保存的 int 变量的更新都是原子操作，保证线程安全。 ctlOf 方法就是组合运行状态和工作线程数量。可以看到，ctlOf 方法是通过按位或的方式来实现的。为什么能这样做呢？因为，这里把一个 int 变量拆成两部分来用。前面3位用来表示状态，后面29位用来表示工程线程数量。所以，工作线程数量最大不能超过 2^29-1 ，ThreadPoolExecutor 的设计者也是考虑不太可能超过这个数，暂时就用了29位。 了解了 ctl 变量的结构，再回过头来看前面提到的两个方法。 1234567891011private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; workerCountOf 方法很好理解，CAPACITY 的值是00011111 … … 11111111，按位与之后去掉了前面三位，保留了后面四位。所以，拿到的就是工作线程的数量。 isRunning 方法中，直接拿 ctl 的值和 SHUTDOWN 作比较。这个要先知道在 RUNNING 状态下，ctl 的值是什么样的。初始状态，ctl 的值是11100000 … … 00000000，表示 RUNNING 状态，和0个工作线程。后面，每创建一个新线程，都把 ctl 加一。当有5个工作线程时，ctl 的值是11100000 … … 00000101。在 RUNNING 状态下，ctl 始终是负值，而 SHUTDOWN 是0，所以可以通过直接比较 ctl 的值来确定状态。 思考善用位运算，有时候可以给我们节省很多空间。但是，在这里，明显不是为了省空间了，因为就算用两个值分开表示状态和工作线程数量，也就8个字节而已。我猜测是为了在多线程环境下保证运行状态和线程数量的统一。把这两个值放到一个 int 变量中，然后用 AtomicInteger 进行存储和读写，就可以保证这两个值始终是统一的。如果用两个变量保存，即使用了 AtomicInteger ，也可能出现一个改了，另一个还没改的情况。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编译时找不到AndroidSDK的问题 | Unable to list target platforms]]></title>
    <url>%2F2018%2F01%2F08%2FUnity%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0AndroidSDK%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[现象在用 Unity 编译 Android 平台的应用时，遇到 Unable to list target platforms 的问题。 详细错误描述如下： Error:Invalid command androidUnityEditor.BuildPlayerWindow:BuildPlayerAndRun() CommandInvokationFailure: Unable to list target platforms. Please make sure the android sdk path is correct. See the Console for more details.C:\Program Files\Java\jdk1.8.0_91\bin\java.exe -Xmx2048M -Dcom.android.sdkmanager.toolsdir=”D:/Android/sdk\tools” -Dfile.encoding=UTF8 -jar “D:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\sdktools.jar” -stderr[Error:Invalid command android]stdout[]UnityEditor.Android.Command.Run (System.Diagnostics.ProcessStartInfo psi, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg)UnityEditor.Android.AndroidSDKTools.RunCommandInternal (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, Int32 memoryMB, System.String workingdir, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg)UnityEditor.Android.AndroidSDKTools.RunCommandSafe (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, Int32 memoryMB, System.String workingdir, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg)UnityEditor.BuildPlayerWindow:BuildPlayerAndRun() 原因原因简单描述Unity 在编译时会调用 Android SDK tools 中的 android 命令，而在新版本的 Android SDK tools 中，android这个命令已经废弃了，导致 Unity 无法正常编译。我的 Android SDK tools 版本是 25.3.1 。 找到问题原因的过程经过再三确认，我配置的 Android SDK 是没问题的。后来我注意到错误描述中有提到“无效的命令 android ”，所以我尝试直接调用 android 这个命令，看是不是有问题。 Error:Invalid command android android 命令是 AndroidSDK 中 tools 目录下的 android.bat 。直接调用，发现这个命令已经废弃了。 The “android” command is no longer available.For manual SDK and AVD management, please use Android Studio.For command-line tools, usetools\bin\sdkmanager.bat and tools\bin\avdmanager.bat 解决方案知道了原因，问题就好解决了。 从官网下载一个旧版本的 Android SDK tools 。tools_r25.2.3-windows.zip。 把原来 SDK 目录下的 tools 备份一下。我是把它重命名成 tools-25.3.1 。 把下载好的旧版本的 tools 解压到 SDK 目录下。 再在 Unity 中重新编译，问题已经解决了。 对比了一下两个版本的 tools，差别真的很大，少了很多东西。比如，做.9图的 draw9patch 就不知道去哪里了。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在简书上用Markdown画流程图]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%9C%A8%E7%AE%80%E4%B9%A6%E4%B8%8A%E7%94%A8Markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[作为一个程序员，经常需要画流程图。而用Markdown画流程图，省心省力，后面需要调整的话也更方便。但是，目前简书上的Markdown还不支持流程图。怎么办呢？只能以迂为直，曲线救国了。 简单的说：简书的Markdown本身不支持流程图，但我们可以找一个支持流程图的Markdown编辑器，画完之后，直接截图上传到简书上就可以了。但是有时候流程图太长，超出一个屏幕的高度，这时候需要用能滚动截图的工具来截。 你将需要： 一款支持流程图的Markdown编辑器。推荐Typora。 一款截图工具。QQ自带的就可以。 一款支持截长图的工具。Mac上可以用Snip。Windows上可以用FSCapture。 编辑流程图第一步，当然是先写好我们的流程图了。这里我使用的工具是Typora。需要注意的是，Typora默认是不支持流程图的，需要在设置中开启这个功能。在设置中切换到Markdown那个tab，然后勾选上对图表（包含流程图）的支持。 Markdown画流程图的语法可以看这篇文章：Markdown笔记：如何画流程图。 先来画一个简单的流程图。123456789st=&gt;start: 开始rain?=&gt;condition: 今天有雨吗？takeAnUmbrella=&gt;operation: 带伞go=&gt;operation: 出门e=&gt;end: 结束st-&gt;rain?rain?(yes)-&gt;takeAnUmbrella-&gt;gorain?(no)-&gt;go-&gt;e 截图下面到了收获成果的时候了，直接在Typora里面截图，然后把图片拖到简书的编辑器里就可以了。小贴士： Typora也支持导出图片，不过如果你的流程图太宽的话，导出的图片不能包含整个流程图。 如果你的流程图确实非常宽，以致于在Typora里需要横向滚动才能显示完全的话，可以先导出成html，在浏览器里面打开，再进行截图。 截长图如果流程比较复杂，流程图的长度超过一个屏幕的高度的话，就需要用到滚动截图的工具了。把Typora编辑好的流程图导出成html，然后用支持滚动截图的工具来截。Mac下Snip可以完全滚动截图的操作，Snip在安装和使用的时候有几点要注意的地方，所以我简单介绍一下。 1. 下载地址Snip官网，只支持Mac。 2. 安装在安装时，如果直接双击打开，会提示“来自身份不明的开发者”，而无法打开。但这个Snip是腾讯做的东西，安全性应该是没有问题的，我们在这里用右键点击，然后选择打开，就可以安装了。 3. 设置 首先需要在系统设置里面，找到安全性与隐私。在辅助功能里，勾选允许Snip控制您的电脑。我猜想是因为Snip在截图的时候需要滚动屏幕，所以需要这个权限。 在Snip的偏好设置里，勾选启动滚动截屏。 4. 使用如果需要滚动截屏，在点击截屏后，直接单击，就会开始滚动截屏。这样截的图可能两边会有较多空白，可以用图片处理工具把多余的部分裁掉（Mac上可以直接用自带的图片预览工具进行裁剪）。]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>简书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017政府工作报告——有意思的点]]></title>
    <url>%2F2018%2F01%2F08%2F2017%E6%94%BF%E5%BA%9C%E5%B7%A5%E4%BD%9C%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9%2F</url>
    <content type="text"><![CDATA[创新创业（多次在不同地方提到） 创新的巨大潜能 创新引领实体经济转型（第四大点专门讲述这个） 中小微企业减税、减负。减少各种其他费用。提出，有关部门要舍小利、顾大益 银行改革，解决中小微企业融资难问题 产权保护 政府简政放权，让市场发挥决定性作用 其他有意思的点 网速提速降费，年内取消手机长途、漫游费。（这一点掌声是最热烈，持续最久的） 房价问题。加快建立房地产平稳发展的长效机制，对于房价压力大的地区，增加住宅用地。 煤，一开始提到去产能，后面环保又提到燃煤问题。 雾霾，研究雾霾形成机理，治理雾霾人人有责。 农业稳定发展（第五大点专门讲农业问题）。关键词：农业保险、农村改革、农村双创、鼓励人才到农村施展才华、3万个农村要通光纤。 政府，多次提到实干。 工匠精神（老罗厉害了） 粤港澳大湾区（第一次听说这个概念，有一种美国湾区的感觉） 外资引入，减少对外资企业的限制，在很多方面，内外资企业一视同仁。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何保存微信文章到Instapaper]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%BE%AE%E4%BF%A1%E6%96%87%E7%AB%A0%E5%88%B0Instapaper%2F</url>
    <content type="text"><![CDATA[Instapaper实现稍后阅读 当在网上看到一篇好的文章时，而又没时间去读完它时，该怎么办呢。以前我会这样做：保持这个标签页不关闭；或者添加到浏览器的书签里；或者通过Evernote来记录文章的链接。但是常常不小心就把保留的标签页关了，而收藏到浏览器或者Evernote的文章也常常不记得回头去看。为了解决这个问题，我用了Instapaper。 Instapaper的界面非常简洁，而且纯粹，非常好的聚焦在阅读文章上。这一点比Pocket要好。PC网页端，看到好的文章时，点一下浏览器插件或者Instapaper的书签就直接保存了。Android端，通过系统的分享选择Instapaper就可以保存文章。 从我切身体会，谈一下使用Instapaper的好处： 随时保存，闲时阅读。 统一阅读环境。Instapaper的简洁界面和提供的划线、记笔记，还有推到Evernote等功能非常棒。 保存文章阅读进度，阅读长文章时特别有用。 归档零散阅读的文章，方便以后查找。 一键保存微信文章到Instapaper 在使用Instapaper过程中发现一个问题：微信文章怎么保存到Instapaper。在网上搜索，大部分网友都是先用浏览器打开，然后用浏览器的分享去添加到Instapaper。尝试了一下，miui自带的浏览器的分享功能比较特殊，不能分享到Instapaper。而且就算可以，这个路径也有些太长了。身为一个Android程序猿，那必须想办法搞定这个问题。既然可以用浏览器打开，那干脆开发一个“浏览器”，用这个特殊的“浏览器”打开的时候就直接分享到Instapaper，这样就可以一步到位了。效果如下。 需要注意： 如果点了用浏览器打开，却没弹出选择浏览器的界面的话，可能是以前选过“总是”。只能先清除一下微信数据（一定要谨慎，微信聊天记录没有在云端保存，最好先自己备份）。 如果弹出了选择浏览器的界面，最好也不要选“总是”，因为以后可能会有一些场景真的需要用浏览器打开。 下载地址：我已经把应用发布到应用宝上。通过微信扫描二维码就可以下载。也可以在应用宝里面搜索“Instapaper微信保存插件”。安装完成之后不会有桌面图标，直接在微信里面使用就可以了。欢迎大家在应用宝里给我评分，或者在文章底下给我留言，谢谢大家支持。 技术实现源码已通过github共享让我们的工具成为一个“浏览器”123456789101112131415&lt;activity android:name="com.gmail.huashadow.savetoinstapaper.ShareActivity" android:theme="@android:style/Theme.Translucent.NoTitleBar" android:icon="@mipmap/instapaper" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt;​ &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt;​ &lt;data android:scheme="http" /&gt; &lt;data android:scheme="https" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 保存到Instapaper123456789101112private void saveToInstapaper() &#123; Intent intent = getIntent(); if (intent.getAction().equals(Intent.ACTION_VIEW)) &#123; Log.d(TAG, intent.getData().toString()); Intent saveToInstapaperIntent = new Intent(Intent.ACTION_SEND); saveToInstapaperIntent.setPackage("com.instapaper.android"); saveToInstapaperIntent.setType("text/plain"); saveToInstapaperIntent.putExtra(Intent.EXTRA_TEXT, intent.getData().toString()); startActivity(saveToInstapaperIntent); &#125; finish();&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习记录】Android深入学习之消息处理机制]]></title>
    <url>%2F2018%2F01%2F08%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%91Android%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[学习过程跟着鸿洋_的博客的思路，结合7.0的源码进行学习，同时参考其他好的文章。 概述主要涉及四个类：Looper、Handler、Message、MessageQueue。Message是消息对象，MessageQueue是消息队列。Looper负责创建消息队列，并进入无限循环不断从消息队列中读取消息。而Handler负责发送消息到消息队列，以及消息的回调处理。 Looper1. Looper类的作用源码的类注释中已经把Looper类的作用和使用方法说得很清楚了。123456789101112131415161718192021222324252627282930/** * Class used to run a message loop for a thread. Threads by default do * not have a message loop associated with them; to create one, call * &#123;@link #prepare&#125; in the thread that is to run the loop, and then * &#123;@link #loop&#125; to have it process messages until the loop is stopped. * * &lt;p&gt;Most interaction with a message loop is through the * &#123;@link Handler&#125; class. * * &lt;p&gt;This is a typical example of the implementation of a Looper thread, * using the separation of &#123;@link #prepare&#125; and &#123;@link #loop&#125; to create an * initial Handler to communicate with the Looper. * * &lt;pre&gt; * class LooperThread extends Thread &#123; * public Handler mHandler; * * public void run() &#123; * Looper.prepare(); * * mHandler = new Handler() &#123; * public void handleMessage(Message msg) &#123; * // process incoming messages here * &#125; * &#125;; * * Looper.loop(); * &#125; * &#125;&lt;/pre&gt; */ Looper类的作用就是让线程进行消息循环。如果一个线程需要消息循环，只需要调用Looper类的prepare方法和loop方法就可以了。因此，Looper类中我们主要关注prepare和loop这两个方法，它们都是static方法。 2. prepare()方法1234567891011private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 这里创建了一个Looper对象，然后保存到一个ThreadLocal的静态变量中。当sThreadLocal中取出的对象不为null时，会抛出异常，保证一个线程中只有一个Looper对象。ThreadLocal后面再研究。 然后看Looper的构造方法。1234567private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 创建了一个MessageQueue（消息队列）。 3. loop()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 其中，Binder.clearCallingIdentity()的作用不清楚，先忽略。执行流程： myLooper方法获取sThreadLocal中保存的Looper实例。因此再loop方法执行前应该先执行prepare方法。 进入无限循环。 从消息队列中取出一条消息，如果没有消息则会阻塞；如果消息队列已释放，则会返回null，退出消息循环。 调用msg.target的dispatchMessage方法处理消息。target就是Handler的实例，负责接收处理这个消息。 回收msg资源。 4. Looper类小结 每个线程最多只能有一个Looper对象。每个Looper对象创建并持有一个MessageQueue对象。 通过调用Looper.loop方法使当前线程进入消息循环。当前线程的Looper对象循环从消息队列中取出消息，交由相应的Handler对象去处理。 Handler1. Handler类的作用还是看源码中的类注释。12345678910111213141516171819202122232425262728293031323334353637383940/** * A Handler allows you to send and process &#123;@link Message&#125; and Runnable * objects associated with a thread's &#123;@link MessageQueue&#125;. Each Handler * instance is associated with a single thread and that thread's message * queue. When you create a new Handler, it is bound to the thread / * message queue of the thread that is creating it -- from that point on, * it will deliver messages and runnables to that message queue and execute * them as they come out of the message queue. * * &lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and * runnables to be executed as some point in the future; and (2) to enqueue * an action to be performed on a different thread than your own. * * &lt;p&gt;Scheduling messages is accomplished with the * &#123;@link #post&#125;, &#123;@link #postAtTime(Runnable, long)&#125;, * &#123;@link #postDelayed&#125;, &#123;@link #sendEmptyMessage&#125;, * &#123;@link #sendMessage&#125;, &#123;@link #sendMessageAtTime&#125;, and * &#123;@link #sendMessageDelayed&#125; methods. The &lt;em&gt;post&lt;/em&gt; versions allow * you to enqueue Runnable objects to be called by the message queue when * they are received; the &lt;em&gt;sendMessage&lt;/em&gt; versions allow you to enqueue * a &#123;@link Message&#125; object containing a bundle of data that will be * processed by the Handler's &#123;@link #handleMessage&#125; method (requiring that * you implement a subclass of Handler). * * &lt;p&gt;When posting or sending to a Handler, you can either * allow the item to be processed as soon as the message queue is ready * to do so, or specify a delay before it gets processed or absolute time for * it to be processed. The latter two allow you to implement timeouts, * ticks, and other timing-based behavior. * * &lt;p&gt;When a * process is created for your application, its main thread is dedicated to * running a message queue that takes care of managing the top-level * application objects (activities, broadcast receivers, etc) and any windows * they create. You can create your own threads, and communicate back with * the main application thread through a Handler. This is done by calling * the same &lt;em&gt;post&lt;/em&gt; or &lt;em&gt;sendMessage&lt;/em&gt; methods as before, but from * your new thread. The given Runnable or Message will then be scheduled * in the Handler's message queue and processed when appropriate. */ Handler用于发送和处理Message和Runnable对象。Handler对象在创建时关联当前线程的MessageQueue，且每个Handler对象只能关联一个MessageQueue。Handler对象发送Message和Runnable对象到关联的MessageQueue，然后当它们从MessageQueue中移出时，负责执行它们。 Handler的主要用途有两个： 定时执行message或runnable。 让其他线程执行某个操作。比如，在非UI线程发送一个消息，让UI线程更新界面。 Handler中重要的有以下几组方法： 构造方法 sendMessage方法 post方法 dispatchMessage方法 2. 构造方法Handler中有很多构造方法，但是最终分别进入到两个构造方法中。先来看下这两个构造方法有什么不同。123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 第二个构造方法前面那段主要是当Handler的之类不是static类时，警告可能会导致内存泄漏。忽略这个，两个方法的区别就在于mLooper这个成员变量的来源。第一个方法由参数传入，而第二个方法是获取当前线程的Looper。可以看到，构造方法里面就是对几个成员变量赋值而已。这里先了解一下这几个成员变量的作用。 mLooper：Looper，消息循环 mQueue：MessageQueue，消息队列，就是mLooper中持有的那个 mCallback：Handler.CallBack，Handler中声明的接口，用于处理消息 mAsynchronous：boolean，发送的消息是否是异步的。那么，这个异步到底是什么意思呢？我们在后面MessageQueue的next方法中再去详细了解。 3. sendMessage方法sendMessage有一系列的方法： sendMessage(Message msg): boolean sendEmptyMessage(int what): boolean sendEmptyMessageDelayed(int what, long delayMillis): boolean sendMessageDelayed(Message msg, long delayMillis): boolean sendEmptyMessageAtTime(int what, long uptimeMillis): boolean sendMessageAtTime(Message msg, long uptimeMillis): boolean sendMessageAtFrontOfQueue(Message msg): boolean 其中，sendMessage、sendEmptyMessage、sendMessageDelayed、sendEmptyMessageDelayed和sendEmptyMessageAtTime方法都调用sendMessageAtTime方法。所以，我们重点看sendMessageAtTime方法和sendMessageAtFrontOfQueue方法。 sendMessageAtTime方法12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; enquueMessage方法只是调用MessageQueue的enqueueMessage方法。1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; uptimeMillis是消息分发的时间，基于SystemClock.uptimeMillis()。比如，sendMessageDelayed方法中使用SystemClock.uptimeMillis()加上延迟的时间。在消息队列中，消息是按分发时间的先后排列的。因此，这里的msg会插入到所有分发时间在uptimeMillis之前的消息后面。 sendMessageAtFrontOfQueue方法12345678910public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125; 顾名思义，sendMessageAtFrontOfQueue方法就是把消息插入到队列的最前面。和sendMessageAtTime唯一的不同是，在调用enqueueMessage方法时传的uptimeMillis参数是0。用0来表示插入到消息队列最前面，也是比较自然的做法。 4. post方法post方法把Runable对象添加到消息队列中，也有一系列方法。 post(Runnable r): boolean postAtTime(Runnable r, long uptimeMillis): boolean postAtTime(Runnable r, Object token, long uptimeMillis): boolean postDelayed(Runnable r, long delayMillis): boolean postAtFrontOfQueue(Runnable r): boolean 这些方法实现都类似，都是通过getPostMessage方法，获取一个Message，同时把Runnable存到Message中，然后调用sendMessage方法。1234public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 比较特殊的是带有token参数的postAtTime方法，这里的token是传给消息接收者的数据，会保存到Message的成员变量obj中。123456private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m;&#125; 5. dispatchMessage方法dispatchMessage方法就是前面Looper中调用的处理消息的方法。 msg.target.dispatchMessage(msg); 先看dispatchMessage方法的源码。123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 如果消息中带有callback，直接执行callback（就是Message带的Runnable）；如果Handler中设置了CallBack，则调用CallBack来处理消息；前面两个都没有的话，才是调用handleMessage方法。handleMessage是空方法，子类可以重写该方法来处理消息。 6. Handler类小结 Handler创建时会关联一个Looper和Looper中持有的MessageQueue。 Handler可以在任意线程发送消息到关联的MessageQueue。 Handler在关联的Looper所在线程处理自己发送的消息。 Hander主要用于定时任务和在其他线程执行任务。 MessageQueue看完了Looper和Handler，已经基本理清了消息机制。再来看一下消息队列是怎么实现的。主要看一下把消息加入队列和从队列中取消息的实现。 1. 消息加入队列MessageQueue的enqueueMessage方法负责把消息加入队列中。就是Handler中添加消息到消息队列调用的方法。下面贴的代码中省略了一下不影响主要逻辑的部分。12345678910111213141516171819202122232425262728293031323334353637boolean enqueueMessage(Message msg, long when) &#123; ...... synchronized (this) &#123; ...... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 成员变量mMessages是消息队列的头部，是一个Message对象。MessageQueue中通过Message的next形成一个链表。如果待插入的消息的分发时间是0，表示直接插入到队列头部。如果队列头部Message为空，或者待插入消息的分发时间小于队列头部Message，也把消息插入到队列头部。如果不满足插入到头部的条件的话，就遍历消息队列，按分发时间找到合适的插入位置。 2. 从队列中获取下一条消息在Looper中已经看到，MessageQueue的next方法负责从队列中取下一条消息。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697Message next() &#123; ... int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // 找下一个消息。找到的话就返回这个消息。 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 被Barrier阻塞。找队列中的下一个异步消息。 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 下一个消息的分发时间还没到。设置一个时间，等到消息准备分发时再唤醒。 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 有一个可以分发的消息。 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // 没有消息，也可能是消息都被Barrier阻塞了。 nextPollTimeoutMillis = -1; &#125; // 消息循环准备退出。释放资源，并且返回null。 if (mQuitting) &#123; dispose(); return null; &#125; // pendingIdleHandlerCount初始值为-1，所以第一次会去获取IdleHandlers的数量。 // IdleHandler在需要等待下一条消息时去运行，因为这时是空闲的。 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // 执行IdleHandler // 只在第一次迭代时会执行，因为后面会把pendingIdleHandlerCount设成0 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // 把pendingIdleHandlerCount设成0，后面的迭代不会再去执行IdleHandlers。 pendingIdleHandlerCount = 0; // 执行完IdleHandler，可能已经有新的消息了，所以不需要再等待了。 nextPollTimeoutMillis = 0; &#125;&#125; 这个方法还是比较复杂的，所以我画了个流程图，能够看得清楚一些。 通过流程图已经能理清next方法的执行过程。但是，还有两个需要解释的地方。一个是Barrier和异步消息，另一个是nativePollOnce这个方法。 Barrier和异步消息Barrier是什么？Barrier是阻塞器，会阻塞消息队列。它也是一个Message对象，只不过它的target是null。从next方法中可以看到，在Barrier后面所有消息，除了异步消息外都无法执行。MessageQueue中对外提供了post和remove的方法。12public int postSyncBarrier();public void removeSyncBarrier(int token); 调用post方法时，会创建一个空的Message对象，时间设为当前的系统时间，同时生成一个token，保存在Message中。这个Message对象会像普通的消息一样被插入到消息队列中。调用remove方法时，根据token从消息队列中找到相应的Barrier，然后移除。看一个具体的例子，这是ViewRootImpl中的一段代码。1234567891011void scheduleTraversals() &#123; ... mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); ...&#125;void unscheduleTraversals() &#123; ... mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); ...&#125; 当要阻塞消息队列时，通过Handler获取到MessageQueue，然后直接调用MessageQueue的postSyncBarrier方法，保存下token。需要取消消息队列的阻塞时，通过先前保存的token去移除Barrier。 nativePollOnce方法nativePollOnce是一个native方法。它的实现在frameworks/base/code/jni目录下的android_os_MessageQueue.cpp中。想要了解怎么找到这个实现的，可以阅读这篇文章：Android JNI原理分析。 1234static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 这里去调用了NativeMessageQueue的pollOnce方法。NativeMessageQueue的对象是在Java层的MessageQueue创建时，同时创建的。12345void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; ... mLooper-&gt;pollOnce(timeoutMillis); ...&#125; 这里调用mLooper的pollOnce方法。这里的mLooper是JNI层的Looper，是在创建NativeMessageQueue时创建的。这个类的实现在system/core/libutils/Looper.cpp中。12345678910111213int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; ... if (result != 0) &#123; ... return result; &#125; result = pollInner(timeoutMillis); &#125;&#125; 我们把pollOnce方法中不太重要的部分都去掉，只留下最主要的部分。实际上就是循环去调用pollInner方法，当pollInner方法的返回结果不为0时，这个方法就可以返回了。下面来看一下pollInner方法的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114int Looper::pollInner(int timeoutMillis) &#123; // Adjust the timeout based on when the next message is due. if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime); if (messageTimeoutMillis &gt;= 0 &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) &#123; timeoutMillis = messageTimeoutMillis; &#125; &#125; // Poll. int result = POLL_WAKE; ... struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // Rebuild epoll set if needed. if (mEpollRebuildRequired) &#123; mEpollRebuildRequired = false; rebuildEpollLocked(); goto Done; &#125; // Check for poll error. if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; ALOGW("Poll failed with an unexpected error: %s", strerror(errno)); result = POLL_ERROR; goto Done; &#125; // Check for poll timeout. if (eventCount == 0) &#123; result = POLL_TIMEOUT; goto Done; &#125; for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW("Ignoring unexpected epoll events 0x%x on wake event fd.", epollEvents); &#125; &#125; else &#123; ... &#125; &#125;Done: ; // Invoke pending message callbacks. mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; // Remove the envelope from the list. // We keep a strong reference to the handler until the call to handleMessage // finishes. Then we drop it so that the handler can be deleted *before* // we reacquire our lock. &#123; // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; &#125; else &#123; // The last message left at the head of the queue determines the next wakeup time. mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; ... // Invoke all response callbacks. for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; // Invoke the callback. Note that the file descriptor may be closed by // the callback (and potentially even reused) before the function returns so // we need to be a little careful when removing the file descriptor afterwards. int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); &#125; // Clear the callback reference in the response structure promptly because we // will not clear the response vector itself until the next poll. response.request.callback.clear(); result = POLL_CALLBACK; &#125; &#125; return result;&#125; pollInner方法中调用了epoll_wait()，等待消息到来，或者等到超时返回。如果有消息到来，则进行处理。 poolInner方法的流程：（摘自[M0]Android Native层Looper详解） 调整timeout： mNextMessageUptime 是 消息队列 mMessageEnvelopes 中最近一个即将要被处理的message的时间点。 所以需要根据mNextMessageUptime 与 调用者传下来的timeoutMillis 比较计算出一个最小的timeout，这将决定epoll_wait() 可能会阻塞多久才会返回。 epoll_wait()：epoll_wait()这里会阻塞，在三种情况下回返回，返回值eventCount为上来的epoll event数量。 出现错误返回， eventCount &lt; 0; timeout返回，eventCount = 0，表明监听的文件描述符中都没有事件发生，将直接进行native message的处理； 监听的文件描述符中有事件发生导致的返回，eventCount &gt; 0; 有eventCount 数量的epoll event 上来。 处理epoll_wait() 返回的epoll events.判断epoll event 是哪个fd上发生的事件 如果是mWakeEventFd，则执行awoken(). awoken() 只是将数据read出来，然后继续往下处理了。其目的也就是使epoll_wait() 从阻塞中返回。 如果是通过Looper.addFd() 接口加入到epoll监听队列的fd，并不是立马处理，而是先push到mResponses，后面再处理。 处理消息队列 mMessageEnvelopes 中的Message. 如果还没有到处理时间，就更新一下mNextMessageUptime 处理刚才放入mResponses中的事件. 只处理 ident 为POLL_CALLBACK的事件。其他事件在 pollOnce 中处理 参考资料 Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系 android的消息处理机制（图+源码分析）——Looper,Handler,Message Android消息处理机制(Handler、Looper、MessageQueue与Message)(里面关于同步消息、异步消息讲得很清楚) Android应用程序消息处理机制（Looper、Handler）分析 Android JNI原理分析 [M0]Android Native层Looper详解]]></content>
      <tags>
        <tag>Android</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity开发中的常用操作和注意事项]]></title>
    <url>%2F2018%2F01%2F08%2FUnity%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[场景视角变换平移：鼠标切换到手型，按下左键拖动缩放：鼠标滚轮滚动；或者按下alt+鼠标右键，然后移动鼠标围绕观察点旋转：按下alt+鼠标左键，然后移动鼠标观察者旋转：按下鼠标右键，然后移动鼠标聚焦到物体：选中物体后按F；或者在hierarchy中双击要聚焦的物体 编辑器布局切换在编辑器上方菜单栏的Windows-&gt;Layouts可以切换不同的布局。有预设的一些布局，也可以自己修改布局然后保存。预设的里面我用的比较多的是Default和2 by 3。Default布局是中间上方有一个很大的场景窗口，可以通过标签页切换到Game窗口；2 by 3是左边分成上下两块，分别显示场景窗口和Game窗口。 VisualStudio首先要安装Visual Studio Tools for Unity。Unity在安装的时候就在VisualStudio中安装了这个插件，如果没有的话可以在VS的插件管理器（Tools-&gt;Extensions and Updates）中下载安装，或者去msdn上下载。 查看unity文档：Help-&gt;Unity API Reference，默认快捷键是 Ctrl + Alt +M,Ctrl + H。会在VS中打开Unity的在线文档，并查找当前选中的内容。快速实现MonoBehaviour中的方法：鼠标右键-&gt;Implement MonoBehaviours(快捷键：Ctrl + Shift + M)。列出MonoBehaviour中所有可实现的方法，通过勾选添加。查看MonoBehaviour中的方法：鼠标右键-&gt;Quick MonoBehaviours（快捷键：Ctrl+shift +Q）。查找MonoBehaviour中可实现的方法。调试脚本：点击Attach to Unity，或者直接按F5连接到Unity上，在Unity中运行游戏，就可以开始断点调试了。 注意：不要在play模式下进行编辑play模式下场景中的修改（场景中创建物体、修改物体属性等）都是临时的，退出play模式时就会还原。play模式下只适合用来做测试性的修改，而不应该在play模式下编辑。问题来了，如何避免不小心在play模式下编辑的情况？可以让Unity在play模式下显示不一样的颜色来提醒自己。在Preference的Colors中修改Playmode tint即可。效果见下图。 版本管理：参考：在Unity项目中使用Git 在 Edit-&gt;Project Settings-&gt;Editor-&gt;Version Control Mode 中选择 Visible Meta files。 在 Edit-&gt;Project Settings-&gt;Editor-&gt;Asset Serialization Mode 中选择 Force Text。 添加gitignore。 下面是Unity官方教程里面给出的gitignore =============== Unity generated =============== Temp/ Library/ ===================================== Visual Studio / MonoDevelop generated ===================================== ExportedObj/ obj/ *.svd *.userprefs /*.csproj *.pidb *.suo /*.sln *.user *.unityproj *.booproj ============ OS generated ============ .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何为NTFS文件系统的移动硬盘划分一个Mac的分区]]></title>
    <url>%2F2018%2F01%2F03%2F%E5%A6%82%E4%BD%95%E4%B8%BANTFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%88%92%E5%88%86%E4%B8%80%E4%B8%AAMac%E7%9A%84%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[1. 背景事情是这样的，我准备编译android源码，但是我的MacPro只有256G的空间，而源码编译大概要100G左右的空间。于是，我从箱底翻出500G的硬盘。只有一个分区，NTFS文件系统的，编译源码需要Mac OS扩展（区分大小写，日志式）。但里面还有300多G的资料、软件、游戏之类的，直接格式化肯定不行，备份又麻烦。所以我准备在移动硬盘上划分一个新的分区，格式化成mac需要的格式。 2. 压缩原有分区并创建Mac OS 扩展分区使用的工具 Windows自带的磁盘管理工具 Mac自带的磁盘管理工具 具体步骤 利用Windows自带的磁盘管理工具，压缩移动硬盘上原有的分区。据说编译源码100G的空间够了，于是我压缩出了100G左右的空间。 利用Windows自带的磁盘管理工具，创建新的分区（使用压缩出的空间）。这里可能因为我的移动硬盘原有的分区是NTFS的，所以无法在Mac上对移动硬盘进行分区，只能先在Windows上分区。 利用Mac自带的磁盘管理工具，格式化新建的分区。 3. 扩展MacOSX分区的大小分区完成之后，下载Android源码进行编译，艰难绕过各种坑之后，在编译到80%时失败了，空间不足！！！于是只能想办法再给MacOSX分区扩展一点空间。 工具 Windows自带的磁盘管理工具 iPartition（Mac上的一个第三方磁盘分区工具） 具体步骤 利用Windows自带的磁盘管理工具，压缩NTFS分区的空间。空间挤挤总是有的，又压缩出50G空间。 利用iPartition工具，把压缩出的50G空间合并到MacOSX分区中。这一步尝试了Windows的磁盘管理工具、Mac的磁盘管理工具还有Windows上的分区助手都没法搞。最后用iPartition轻松搞定。]]></content>
  </entry>
</search>
